<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: libavutil/hwcontext.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8d855866ba5d436d839c7fc557836cd9.html">libavutil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hwcontext.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="buffer_8h_source.html">buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="frame_8h_source.html">frame.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log_8h_source.html">log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pixfmt_8h_source.html">pixfmt.h</a>&quot;</code><br />
</div>
<p><a href="hwcontext_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAVHWDeviceContext.html">AVHWDeviceContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct aggregates all the (hardware/vendor-specific) "high-level" state, i.e.  <a href="structAVHWDeviceContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAVHWFramesContext.html">AVHWFramesContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct describes a set or pool of "hardware" frames (i.e.  <a href="structAVHWFramesContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAVHWFramesConstraints.html">AVHWFramesConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct describes the constraints on hardware frames attached to a given device with a hardware-specific configuration.  <a href="structAVHWFramesConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acf25724be4b066a51ad86aa9214b0d34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34">AVHWDeviceType</a> { <br />
&#160;&#160;<a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34a41592a72e14c349fae1277a46268c29a">AV_HWDEVICE_TYPE_VDPAU</a>, 
<a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34a8447d4488b0fc4113c281cbdc6e7334e">AV_HWDEVICE_TYPE_CUDA</a>, 
<a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34af5dfa6181a3a6efb0f4a0c5f38d76b95">AV_HWDEVICE_TYPE_VAAPI</a>, 
<a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34acc6f1868dad1c636d4747cc91ce71d10">AV_HWDEVICE_TYPE_DXVA2</a>, 
<br />
&#160;&#160;<a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34a7a74cd2f21d680a11aa8b321ddff1358">AV_HWDEVICE_TYPE_QSV</a>
<br />
 }</td></tr>
<tr class="separator:acf25724be4b066a51ad86aa9214b0d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8d70ed754b2536ca497d7d50ec7b1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#aba8d70ed754b2536ca497d7d50ec7b1e">AVHWFrameTransferDirection</a> { <a class="el" href="hwcontext_8h.html#aba8d70ed754b2536ca497d7d50ec7b1eae8d368e74899ae136a198bf469c0c6db">AV_HWFRAME_TRANSFER_DIRECTION_FROM</a>, 
<a class="el" href="hwcontext_8h.html#aba8d70ed754b2536ca497d7d50ec7b1eae5219126b03aab37ca8b466b8f337ec6">AV_HWFRAME_TRANSFER_DIRECTION_TO</a>
 }</td></tr>
<tr class="separator:aba8d70ed754b2536ca497d7d50ec7b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1cb1f874bb5a0ed7743f9a2b73b47e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a1cb1f874bb5a0ed7743f9a2b73b47e6e">av_hwdevice_ctx_alloc</a> (enum <a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34">AVHWDeviceType</a> type)</td></tr>
<tr class="memdesc:a1cb1f874bb5a0ed7743f9a2b73b47e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> for a given pixel format.  <a href="#a1cb1f874bb5a0ed7743f9a2b73b47e6e">More...</a><br /></td></tr>
<tr class="separator:a1cb1f874bb5a0ed7743f9a2b73b47e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d8c9101c95cdcab3dbc5b4c03dfd4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a11d8c9101c95cdcab3dbc5b4c03dfd4d">av_hwdevice_ctx_init</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *<a class="el" href="tests_2jpeg2000dwt_8c.html#a5cabdd8be5af41f675fed06498e094b7">ref</a>)</td></tr>
<tr class="memdesc:a11d8c9101c95cdcab3dbc5b4c03dfd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the device context before use.  <a href="#a11d8c9101c95cdcab3dbc5b4c03dfd4d">More...</a><br /></td></tr>
<tr class="separator:a11d8c9101c95cdcab3dbc5b4c03dfd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085a5abc44c5330b64489416a42482d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#ac085a5abc44c5330b64489416a42482d">av_hwdevice_ctx_create</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> **device_ctx, enum <a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34">AVHWDeviceType</a> type, const char *device, <a class="el" href="structAVDictionary.html">AVDictionary</a> *<a class="el" href="tests_2movenc_8c.html#af540b728145b614e34c4e10930354b93">opts</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="log_8c.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:ac085a5abc44c5330b64489416a42482d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a device of the specified type and create an <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> for it.  <a href="#ac085a5abc44c5330b64489416a42482d">More...</a><br /></td></tr>
<tr class="separator:ac085a5abc44c5330b64489416a42482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f93ecf13855387e89d6d5e34054b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a48f93ecf13855387e89d6d5e34054b11">av_hwframe_ctx_alloc</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *device_ctx)</td></tr>
<tr class="memdesc:a48f93ecf13855387e89d6d5e34054b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> tied to a given device context.  <a href="#a48f93ecf13855387e89d6d5e34054b11">More...</a><br /></td></tr>
<tr class="separator:a48f93ecf13855387e89d6d5e34054b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a7e1ebc7e459ce07d3de6639ac7e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a66a7e1ebc7e459ce07d3de6639ac7e38">av_hwframe_ctx_init</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *<a class="el" href="tests_2jpeg2000dwt_8c.html#a5cabdd8be5af41f675fed06498e094b7">ref</a>)</td></tr>
<tr class="memdesc:a66a7e1ebc7e459ce07d3de6639ac7e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the context before use.  <a href="#a66a7e1ebc7e459ce07d3de6639ac7e38">More...</a><br /></td></tr>
<tr class="separator:a66a7e1ebc7e459ce07d3de6639ac7e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e7cf122b61f6472d0a4d37f52d4965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a03e7cf122b61f6472d0a4d37f52d4965">av_hwframe_get_buffer</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *hwframe_ctx, <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="log_8c.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:a03e7cf122b61f6472d0a4d37f52d4965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new frame attached to the given <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a>.  <a href="#a03e7cf122b61f6472d0a4d37f52d4965">More...</a><br /></td></tr>
<tr class="separator:a03e7cf122b61f6472d0a4d37f52d4965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1b1664b8239d953ae2cac8b643815a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#abf1b1664b8239d953ae2cac8b643815a">av_hwframe_transfer_data</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *dst, const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="avxsynth__c_8h.html#a67caf60f8ec76e0adc7b693bfb651b66">src</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="log_8c.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:abf1b1664b8239d953ae2cac8b643815a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data to or from a hw surface.  <a href="#abf1b1664b8239d953ae2cac8b643815a">More...</a><br /></td></tr>
<tr class="separator:abf1b1664b8239d953ae2cac8b643815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae758c36d3b0c446af7f9eb1f57110a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#ae758c36d3b0c446af7f9eb1f57110a49">av_hwframe_transfer_get_formats</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *hwframe_ctx, enum <a class="el" href="hwcontext_8h.html#aba8d70ed754b2536ca497d7d50ec7b1e">AVHWFrameTransferDirection</a> dir, enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> **<a class="el" href="tests_2swresample_8c.html#abfa4bbe60c22a0b9322fd965a970d9c1">formats</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="log_8c.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:ae758c36d3b0c446af7f9eb1f57110a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of possible source or target formats usable in <a class="el" href="hwcontext_8h.html#abf1b1664b8239d953ae2cac8b643815a" title="Copy data to or from a hw surface. ">av_hwframe_transfer_data()</a>.  <a href="#ae758c36d3b0c446af7f9eb1f57110a49">More...</a><br /></td></tr>
<tr class="separator:ae758c36d3b0c446af7f9eb1f57110a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc6d255d84b533ce27aa1fdd8021484"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#aebc6d255d84b533ce27aa1fdd8021484">av_hwdevice_hwconfig_alloc</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *device_ctx)</td></tr>
<tr class="memdesc:aebc6d255d84b533ce27aa1fdd8021484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a HW-specific configuration structure for a given HW device.  <a href="#aebc6d255d84b533ce27aa1fdd8021484">More...</a><br /></td></tr>
<tr class="separator:aebc6d255d84b533ce27aa1fdd8021484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f4c1184e1758150b6d9bc0adf2c1df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVHWFramesConstraints.html">AVHWFramesConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a80f4c1184e1758150b6d9bc0adf2c1df">av_hwdevice_get_hwframe_constraints</a> (<a class="el" href="structAVBufferRef.html">AVBufferRef</a> *<a class="el" href="tests_2jpeg2000dwt_8c.html#a5cabdd8be5af41f675fed06498e094b7">ref</a>, const <a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> *hwconfig)</td></tr>
<tr class="memdesc:a80f4c1184e1758150b6d9bc0adf2c1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraints on HW frames given a device and the HW-specific configuration to be used with that device.  <a href="#a80f4c1184e1758150b6d9bc0adf2c1df">More...</a><br /></td></tr>
<tr class="separator:a80f4c1184e1758150b6d9bc0adf2c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29da7fa7ffa73266d1cbfccb116ed634"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hwcontext_8h.html#a29da7fa7ffa73266d1cbfccb116ed634">av_hwframe_constraints_free</a> (<a class="el" href="structAVHWFramesConstraints.html">AVHWFramesConstraints</a> **constraints)</td></tr>
<tr class="memdesc:a29da7fa7ffa73266d1cbfccb116ed634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an AVHWFrameConstraints structure.  <a href="#a29da7fa7ffa73266d1cbfccb116ed634">More...</a><br /></td></tr>
<tr class="separator:a29da7fa7ffa73266d1cbfccb116ed634"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acf25724be4b066a51ad86aa9214b0d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf25724be4b066a51ad86aa9214b0d34">&sect;&nbsp;</a></span>AVHWDeviceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34">AVHWDeviceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf25724be4b066a51ad86aa9214b0d34a41592a72e14c349fae1277a46268c29a"></a>AV_HWDEVICE_TYPE_VDPAU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acf25724be4b066a51ad86aa9214b0d34a8447d4488b0fc4113c281cbdc6e7334e"></a>AV_HWDEVICE_TYPE_CUDA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acf25724be4b066a51ad86aa9214b0d34af5dfa6181a3a6efb0f4a0c5f38d76b95"></a>AV_HWDEVICE_TYPE_VAAPI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acf25724be4b066a51ad86aa9214b0d34acc6f1868dad1c636d4747cc91ce71d10"></a>AV_HWDEVICE_TYPE_DXVA2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acf25724be4b066a51ad86aa9214b0d34a7a74cd2f21d680a11aa8b321ddff1358"></a>AV_HWDEVICE_TYPE_QSV&#160;</td><td class="fielddoc"></td></tr>
</table>

<p>Definition at line <a class="el" href="hwcontext_8h_source.html#l00027">27</a> of file <a class="el" href="hwcontext_8h_source.html">hwcontext.h</a>.</p>

</div>
</div>
<a id="aba8d70ed754b2536ca497d7d50ec7b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8d70ed754b2536ca497d7d50ec7b1e">&sect;&nbsp;</a></span>AVHWFrameTransferDirection</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="hwcontext_8h.html#aba8d70ed754b2536ca497d7d50ec7b1e">AVHWFrameTransferDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba8d70ed754b2536ca497d7d50ec7b1eae8d368e74899ae136a198bf469c0c6db"></a>AV_HWFRAME_TRANSFER_DIRECTION_FROM&#160;</td><td class="fielddoc"><p>Transfer the data from the queried hw frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba8d70ed754b2536ca497d7d50ec7b1eae5219126b03aab37ca8b466b8f337ec6"></a>AV_HWFRAME_TRANSFER_DIRECTION_TO&#160;</td><td class="fielddoc"><p>Transfer the data to the queried hw frame. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="hwcontext_8h_source.html#l00336">336</a> of file <a class="el" href="hwcontext_8h_source.html">hwcontext.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1cb1f874bb5a0ed7743f9a2b73b47e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb1f874bb5a0ed7743f9a2b73b47e6e">&sect;&nbsp;</a></span>av_hwdevice_ctx_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVBufferRef.html">AVBufferRef</a>* av_hwdevice_ctx_alloc </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34">AVHWDeviceType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> for a given pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a hwaccel pixel format (AV_PIX_FMT_FLAG_HWACCEL must be set on the corresponding format descriptor) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly created <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> on success or NULL on failure. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00074">74</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="hwcontext_8c_source.html#l00463">av_hwdevice_ctx_create()</a>, and <a class="el" href="hwcontext__qsv_8c_source.html#l00171">qsv_init_child_ctx()</a>.</p>

</div>
</div>
<a id="a11d8c9101c95cdcab3dbc5b4c03dfd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d8c9101c95cdcab3dbc5b4c03dfd4d">&sect;&nbsp;</a></span>av_hwdevice_ctx_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hwdevice_ctx_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize the device context before use. </p>
<p>This function must be called after the context is filled with all the required information and before it is used in any way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>a reference to the <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00132">132</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="hwcontext_8c_source.html#l00463">av_hwdevice_ctx_create()</a>, and <a class="el" href="hwcontext__qsv_8c_source.html#l00171">qsv_init_child_ctx()</a>.</p>

</div>
</div>
<a id="ac085a5abc44c5330b64489416a42482d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac085a5abc44c5330b64489416a42482d">&sect;&nbsp;</a></span>av_hwdevice_ctx_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hwdevice_ctx_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> **&#160;</td>
          <td class="paramname"><em>device_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="hwcontext_8h.html#acf25724be4b066a51ad86aa9214b0d34">AVHWDeviceType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVDictionary.html">AVDictionary</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a device of the specified type and create an <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> for it. </p>
<p>This is a convenience function intended to cover the simple cases. Callers who need to fine-tune device creation/management should open the device manually and then wrap it in an <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> using <a class="el" href="hwcontext_8h.html#a1cb1f874bb5a0ed7743f9a2b73b47e6e" title="Allocate an AVHWDeviceContext for a given pixel format. ">av_hwdevice_ctx_alloc()</a>/av_hwdevice_ctx_init().</p>
<p>The returned context is already initialized and ready for use, the caller should not call <a class="el" href="hwcontext_8h.html#a11d8c9101c95cdcab3dbc5b4c03dfd4d" title="Finalize the device context before use. ">av_hwdevice_ctx_init()</a> on it. The user_opaque/free fields of the created <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a> are set by this function and should not be touched by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_ctx</td><td>On success, a reference to the newly-created device context will be written here. The reference is owned by the caller and must be released with <a class="el" href="group__lavu__buffer.html#ga135e9e929b5033bb8f68322497b2effc" title="Free a given reference and automatically free the buffer if there are no more references to it...">av_buffer_unref()</a> when no longer needed. On failure, NULL will be written to this pointer. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the device to create. </td></tr>
    <tr><td class="paramname">device</td><td>A type-specific string identifying the device to open. </td></tr>
    <tr><td class="paramname">opts</td><td>A dictionary of additional (type-specific) options to use in opening the device. The dictionary remains owned by the caller. </td></tr>
    <tr><td class="paramname">flags</td><td>currently unused</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00463">463</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__hwupload__cuda_8c_source.html#l00037">cudaupload_init()</a>, <a class="el" href="cuvid_8c_source.html#l00656">cuvid_decode_init()</a>, <a class="el" href="ffmpeg__cuvid_8c_source.html#l00060">cuvid_transcode_init()</a>, <a class="el" href="ffmpeg__dxva2_8c_source.html#l00160">dxva2_alloc()</a>, <a class="el" href="hwcontext__qsv_8c_source.html#l00706">qsv_device_create()</a>, <a class="el" href="ffmpeg__qsv_8c_source.html#l00044">qsv_device_init()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00526">vaapi_device_init()</a>, and <a class="el" href="ffmpeg__vdpau_8c_source.html#l00082">vdpau_alloc()</a>.</p>

</div>
</div>
<a id="a48f93ecf13855387e89d6d5e34054b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f93ecf13855387e89d6d5e34054b11">&sect;&nbsp;</a></span>av_hwframe_ctx_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVBufferRef.html">AVBufferRef</a>* av_hwframe_ctx_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>device_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> tied to a given device context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_ctx</td><td>a reference to a <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a>. This function will make a new reference for internal use, the one passed to the function remains owned by the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly created <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> on success or NULL on failure. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00177">177</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__hwupload__cuda_8c_source.html#l00082">cudaupload_config_output()</a>, <a class="el" href="cuvid_8c_source.html#l00656">cuvid_decode_init()</a>, <a class="el" href="ffmpeg__cuvid_8c_source.html#l00060">cuvid_transcode_init()</a>, <a class="el" href="ffmpeg__dxva2_8c_source.html#l00265">dxva2_create_decoder()</a>, <a class="el" href="vf__hwupload_8c_source.html#l00098">hwupload_config_output()</a>, <a class="el" href="vf__scale__npp_8c_source.html#l00177">init_stage()</a>, <a class="el" href="ffmpeg__qsv_8c_source.html#l00058">qsv_init()</a>, <a class="el" href="hwcontext__qsv_8c_source.html#l00171">qsv_init_child_ctx()</a>, <a class="el" href="ffmpeg__qsv_8c_source.html#l00098">qsv_transcode_init()</a>, <a class="el" href="vf__scale__vaapi_8c_source.html#l00111">scale_vaapi_config_output()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00411">vaapi_decode_init()</a>, <a class="el" href="vaapi__encode_8c_source.html#l01185">vaapi_encode_create_recon_frames()</a>, and <a class="el" href="ffmpeg__vdpau_8c_source.html#l00082">vdpau_alloc()</a>.</p>

</div>
</div>
<a id="a66a7e1ebc7e459ce07d3de6639ac7e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a7e1ebc7e459ce07d3de6639ac7e38">&sect;&nbsp;</a></span>av_hwframe_ctx_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hwframe_ctx_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize the context before use. </p>
<p>This function must be called after the context is filled with all the required information and before it is attached to any frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>a reference to the <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00263">263</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__hwupload__cuda_8c_source.html#l00082">cudaupload_config_output()</a>, <a class="el" href="ffmpeg__dxva2_8c_source.html#l00265">dxva2_create_decoder()</a>, <a class="el" href="vf__hwupload_8c_source.html#l00098">hwupload_config_output()</a>, <a class="el" href="vf__scale__npp_8c_source.html#l00177">init_stage()</a>, <a class="el" href="ffmpeg__qsv_8c_source.html#l00058">qsv_init()</a>, <a class="el" href="hwcontext__qsv_8c_source.html#l00171">qsv_init_child_ctx()</a>, <a class="el" href="ffmpeg__qsv_8c_source.html#l00098">qsv_transcode_init()</a>, <a class="el" href="vf__scale__vaapi_8c_source.html#l00111">scale_vaapi_config_output()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00411">vaapi_decode_init()</a>, <a class="el" href="vaapi__encode_8c_source.html#l01185">vaapi_encode_create_recon_frames()</a>, and <a class="el" href="ffmpeg__vdpau_8c_source.html#l00082">vdpau_alloc()</a>.</p>

</div>
</div>
<a id="a03e7cf122b61f6472d0a4d37f52d4965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e7cf122b61f6472d0a4d37f52d4965">&sect;&nbsp;</a></span>av_hwframe_get_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hwframe_get_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>hwframe_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new frame attached to the given <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwframe_ctx</td><td>a reference to an <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> </td></tr>
    <tr><td class="paramname">frame</td><td>an empty (freshly allocated or unreffed) frame to be filled with newly allocated buffers. </td></tr>
    <tr><td class="paramname">flags</td><td>currently unused, should be set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00394">394</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="libavcodec_2utils_8c_source.html#l00723">avcodec_default_get_buffer2()</a>, <a class="el" href="vf__hwupload__cuda_8c_source.html#l00113">cudaupload_filter_frame()</a>, <a class="el" href="cuvid_8c_source.html#l00398">cuvid_output_frame()</a>, <a class="el" href="ffmpeg__dxva2_8c_source.html#l00130">dxva2_get_buffer()</a>, <a class="el" href="hwcontext_8c_source.html#l00235">hwframe_pool_prealloc()</a>, <a class="el" href="vf__hwupload_8c_source.html#l00153">hwupload_filter_frame()</a>, <a class="el" href="vf__scale__npp_8c_source.html#l00177">init_stage()</a>, <a class="el" href="vf__scale__npp_8c_source.html#l00531">nppscale_scale()</a>, <a class="el" href="ffmpeg__qsv_8c_source.html#l00031">qsv_get_buffer()</a>, <a class="el" href="vf__scale__vaapi_8c_source.html#l00253">scale_vaapi_filter_frame()</a>, <a class="el" href="vaapi__encode_8c_source.html#l00129">vaapi_encode_issue()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00083">vaapi_get_buffer()</a>, and <a class="el" href="ffmpeg__vdpau_8c_source.html#l00052">vdpau_get_buffer()</a>.</p>

</div>
</div>
<a id="abf1b1664b8239d953ae2cac8b643815a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1b1664b8239d953ae2cac8b643815a">&sect;&nbsp;</a></span>av_hwframe_transfer_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hwframe_transfer_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data to or from a hw surface. </p>
<p>At least one of dst/src must have an <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> attached.</p>
<p>If src has an <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> attached, then the format of dst (if set) must use one of the formats returned by av_hwframe_transfer_get_formats(src, AV_HWFRAME_TRANSFER_DIRECTION_FROM). If dst has an <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e. ">AVHWFramesContext</a> attached, then the format of src must use one of the formats returned by av_hwframe_transfer_get_formats(dst, AV_HWFRAME_TRANSFER_DIRECTION_TO)</p>
<p>dst may be "clean" (i.e. with data/buf pointers unset), in which case the data buffers will be allocated by this function using <a class="el" href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb" title="Allocate new buffer(s) for audio or video data. ">av_frame_get_buffer()</a>. If dst-&gt;format is set, then this format will be used, otherwise (when dst-&gt;format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.</p>
<p>The two frames must have matching allocated dimensions (i.e. equal to <a class="el" href="structAVHWFramesContext.html#a9e6f29d0f744930cdd0e8bdff8771520" title="The allocated dimensions of the frames in this pool. ">AVHWFramesContext.width</a>/height), since not all device types support transferring a sub-rectangle of the whole surface. The display dimensions (i.e. <a class="el" href="structAVFrame.html#a1e71ce60cedd5f3b6811714a9f7f9e0a" title="width and height of the video frame ">AVFrame.width</a>/height) may be smaller than the allocated dimensions, but also have to be equal for both frames. When the display dimensions are smaller than the allocated dimensions, the content of the padding in the destination frame is unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination frame. dst is not touched on failure. </td></tr>
    <tr><td class="paramname">src</td><td>the source frame. </td></tr>
    <tr><td class="paramname">flags</td><td>currently unused, should be set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR error code on failure. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00368">368</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__hwupload__cuda_8c_source.html#l00113">cudaupload_filter_frame()</a>, <a class="el" href="cuvid_8c_source.html#l00398">cuvid_output_frame()</a>, <a class="el" href="ffmpeg__dxva2_8c_source.html#l00138">dxva2_retrieve_data()</a>, <a class="el" href="vf__hwdownload_8c_source.html#l00125">hwdownload_filter_frame()</a>, <a class="el" href="vf__hwupload_8c_source.html#l00153">hwupload_filter_frame()</a>, <a class="el" href="hwcontext_8c_source.html#l00322">transfer_data_alloc()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00099">vaapi_retrieve_data()</a>, and <a class="el" href="ffmpeg__vdpau_8c_source.html#l00060">vdpau_retrieve_data()</a>.</p>

</div>
</div>
<a id="ae758c36d3b0c446af7f9eb1f57110a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae758c36d3b0c446af7f9eb1f57110a49">&sect;&nbsp;</a></span>av_hwframe_transfer_get_formats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hwframe_transfer_get_formats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>hwframe_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="hwcontext_8h.html#aba8d70ed754b2536ca497d7d50ec7b1e">AVHWFrameTransferDirection</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5">AVPixelFormat</a> **&#160;</td>
          <td class="paramname"><em>formats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of possible source or target formats usable in <a class="el" href="hwcontext_8h.html#abf1b1664b8239d953ae2cac8b643815a" title="Copy data to or from a hw surface. ">av_hwframe_transfer_data()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwframe_ctx</td><td>the frame context to obtain the information for </td></tr>
    <tr><td class="paramname">dir</td><td>the direction of the transfer </td></tr>
    <tr><td class="paramname">formats</td><td>the pointer to the output format list will be written here. The list is terminated with AV_PIX_FMT_NONE and must be freed by the caller when no longer needed using <a class="el" href="tableprint__vlc_8h.html#a079eab092887563f2bef9106c6120089">av_free()</a>. If this function returns successfully, the format list will have at least one item (not counting the terminator). On failure, the contents of this pointer are unspecified. </td></tr>
    <tr><td class="paramname">flags</td><td>currently unused, should be set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR code on failure. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00310">310</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__hwdownload_8c_source.html#l00087">hwdownload_config_output()</a>, and <a class="el" href="hwcontext_8c_source.html#l00322">transfer_data_alloc()</a>.</p>

</div>
</div>
<a id="aebc6d255d84b533ce27aa1fdd8021484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc6d255d84b533ce27aa1fdd8021484">&sect;&nbsp;</a></span>av_hwdevice_hwconfig_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>* av_hwdevice_hwconfig_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>device_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a HW-specific configuration structure for a given HW device. </p>
<p>After use, the user must free all members as required by the specific hardware structure being used, then free the structure itself with <a class="el" href="tableprint__vlc_8h.html#a079eab092887563f2bef9106c6120089">av_free()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_ctx</td><td>a reference to the associated <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created HW-specific configuration structure on success or NULL on failure. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00418">418</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__scale__vaapi_8c_source.html#l00111">scale_vaapi_config_output()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00186">vaapi_build_decoder_config()</a>, and <a class="el" href="vaapi__encode_8c_source.html#l01185">vaapi_encode_create_recon_frames()</a>.</p>

</div>
</div>
<a id="a80f4c1184e1758150b6d9bc0adf2c1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f4c1184e1758150b6d9bc0adf2c1df">&sect;&nbsp;</a></span>av_hwdevice_get_hwframe_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVHWFramesConstraints.html">AVHWFramesConstraints</a>* av_hwdevice_get_hwframe_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> *&#160;</td>
          <td class="paramname"><em>hwconfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the constraints on HW frames given a device and the HW-specific configuration to be used with that device. </p>
<p>If no HW-specific configuration is provided, returns the maximum possible capabilities of the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_ctx</td><td>a reference to the associated <a class="el" href="structAVHWDeviceContext.html" title="This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. ">AVHWDeviceContext</a>. </td></tr>
    <tr><td class="paramname">hwconfig</td><td>a filled HW-specific configuration structure, or NULL to return the maximum possible capabilities of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structAVHWFramesConstraints.html" title="This struct describes the constraints on hardware frames attached to a given device with a hardware-s...">AVHWFramesConstraints</a> structure describing the constraints on the device, or NULL if not available. </dd></dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00429">429</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="vf__hwupload_8c_source.html#l00041">hwupload_query_formats()</a>, <a class="el" href="vf__scale__vaapi_8c_source.html#l00111">scale_vaapi_config_output()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00186">vaapi_build_decoder_config()</a>, and <a class="el" href="vaapi__encode_8c_source.html#l01185">vaapi_encode_create_recon_frames()</a>.</p>

</div>
</div>
<a id="a29da7fa7ffa73266d1cbfccb116ed634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29da7fa7ffa73266d1cbfccb116ed634">&sect;&nbsp;</a></span>av_hwframe_constraints_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hwframe_constraints_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVHWFramesConstraints.html">AVHWFramesConstraints</a> **&#160;</td>
          <td class="paramname"><em>constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an AVHWFrameConstraints structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraints</td><td>The (filled or unfilled) AVHWFrameConstraints structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hwcontext_8c_source.html#l00454">454</a> of file <a class="el" href="hwcontext_8c_source.html">hwcontext.c</a>.</p>

<p>Referenced by <a class="el" href="hwcontext_8c_source.html#l00429">av_hwdevice_get_hwframe_constraints()</a>, <a class="el" href="vf__hwupload_8c_source.html#l00041">hwupload_query_formats()</a>, <a class="el" href="vf__scale__vaapi_8c_source.html#l00111">scale_vaapi_config_output()</a>, <a class="el" href="ffmpeg__vaapi_8c_source.html#l00186">vaapi_build_decoder_config()</a>, and <a class="el" href="vaapi__encode_8c_source.html#l01185">vaapi_encode_create_recon_frames()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 2 2017 22:49:02 for FFmpeg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
