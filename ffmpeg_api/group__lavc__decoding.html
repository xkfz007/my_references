<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: Decoding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Decoding<div class="ingroups"><a class="el" href="group__libavc.html">libavcodec</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__lavc__parsing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__parsing.html">Frame parsing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8f5b632a03ce83ac8e025894b1fc307a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga8f5b632a03ce83ac8e025894b1fc307a">AV_INPUT_BUFFER_PADDING_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ga8f5b632a03ce83ac8e025894b1fc307a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required number of additionally allocated bytes at the end of the input bitstream for decoding.  <a href="#ga8f5b632a03ce83ac8e025894b1fc307a">More...</a><br /></td></tr>
<tr class="separator:ga8f5b632a03ce83ac8e025894b1fc307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga352363bce7d3ed82c101b3bc001d1c16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> { <br />
&#160;&#160;<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a93d0436f7651b58debe3f995e2582dcd">AVDISCARD_NONE</a> =-16, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a81453d8c452e8ee794daf7fde1c80b5b">AVDISCARD_DEFAULT</a> = 0, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16ac5a5a87ffcd6fb2362ac18449d29bde8">AVDISCARD_NONREF</a> = 8, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a776541ad00a4f13c3fdcd363988bffb3">AVDISCARD_BIDIR</a> = 16, 
<br />
&#160;&#160;<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16aabee31ca5c7c140d3a84b848164eeaf8">AVDISCARD_NONINTRA</a> = 24, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a31c8164477d9f571f82003065d2ab6f1">AVDISCARD_NONKEY</a> = 32, 
<a class="el" href="group__lavc__decoding.html#gga352363bce7d3ed82c101b3bc001d1c16a07517e3890ba7e19a612945483dc066a">AVDISCARD_ALL</a> = 48
<br />
 }</td></tr>
<tr class="separator:ga352363bce7d3ed82c101b3bc001d1c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga19a0ca553277f019dd5b0fec6e1f9dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVCodec.html">AVCodec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga19a0ca553277f019dd5b0fec6e1f9dca">avcodec_find_decoder</a> (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> <a class="el" href="mxfenc_8c.html#a92ba2b3ed65ae251e69195d3ebe639b6">id</a>)</td></tr>
<tr class="memdesc:ga19a0ca553277f019dd5b0fec6e1f9dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a registered decoder with a matching codec ID.  <a href="#ga19a0ca553277f019dd5b0fec6e1f9dca">More...</a><br /></td></tr>
<tr class="separator:ga19a0ca553277f019dd5b0fec6e1f9dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776f2359007e8457799503068419e791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVCodec.html">AVCodec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga776f2359007e8457799503068419e791">avcodec_find_decoder_by_name</a> (const char *<a class="el" href="checkasm_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>)</td></tr>
<tr class="memdesc:ga776f2359007e8457799503068419e791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a registered decoder with the specified name.  <a href="#ga776f2359007e8457799503068419e791">More...</a><br /></td></tr>
<tr class="separator:ga776f2359007e8457799503068419e791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09dee227d3666720eff1f6913d11699d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga09dee227d3666720eff1f6913d11699d">avcodec_default_get_buffer2</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *<a class="el" href="avxsynth__c_8h.html#ab87f55bd0280d90925050a4188c14ab5">s</a>, <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="log_8c.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:ga09dee227d3666720eff1f6913d11699d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default callback for <a class="el" href="structAVCodecContext.html#aef79333a4c6abf1628c55d75ec82bede" title="This callback is called at the beginning of each frame to get data buffer(s) for it. ">AVCodecContext.get_buffer2()</a>.  <a href="#ga09dee227d3666720eff1f6913d11699d">More...</a><br /></td></tr>
<tr class="separator:ga09dee227d3666720eff1f6913d11699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad92aaeee369795273fc6cfc6ef3b189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libswscale_2utils_8c.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#gaad92aaeee369795273fc6cfc6ef3b189">avcodec_get_edge_width</a> (<a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>)</td></tr>
<tr class="memdesc:gaad92aaeee369795273fc6cfc6ef3b189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of padding in pixels which the get_buffer callback must provide around the edge of the image for codecs which do not have the CODEC_FLAG_EMU_EDGE flag.  <a href="#gaad92aaeee369795273fc6cfc6ef3b189">More...</a><br /></td></tr>
<tr class="separator:gaad92aaeee369795273fc6cfc6ef3b189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48432a3760eec9fce0f0ef7b298859f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga48432a3760eec9fce0f0ef7b298859f1">avcodec_align_dimensions</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *<a class="el" href="avxsynth__c_8h.html#ab87f55bd0280d90925050a4188c14ab5">s</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *<a class="el" href="tests_2utils_8c.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *<a class="el" href="tests_2utils_8c.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>)</td></tr>
<tr class="memdesc:ga48432a3760eec9fce0f0ef7b298859f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding.  <a href="#ga48432a3760eec9fce0f0ef7b298859f1">More...</a><br /></td></tr>
<tr class="separator:ga48432a3760eec9fce0f0ef7b298859f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e3269dc1b9e2c98e9371241722e7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga34e3269dc1b9e2c98e9371241722e7e2">avcodec_align_dimensions2</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *<a class="el" href="avxsynth__c_8h.html#ab87f55bd0280d90925050a4188c14ab5">s</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *<a class="el" href="tests_2utils_8c.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *<a class="el" href="tests_2utils_8c.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> linesize_align[<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>])</td></tr>
<tr class="memdesc:ga34e3269dc1b9e2c98e9371241722e7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i].  <a href="#ga34e3269dc1b9e2c98e9371241722e7e2">More...</a><br /></td></tr>
<tr class="separator:ga34e3269dc1b9e2c98e9371241722e7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29744651709d05d125982e6ca20fcd95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga29744651709d05d125982e6ca20fcd95">avcodec_enum_to_chroma_pos</a> (<a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *xpos, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *ypos, enum <a class="el" href="pixfmt_8h.html#a1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a> pos)</td></tr>
<tr class="memdesc:ga29744651709d05d125982e6ca20fcd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts AVChromaLocation to swscale x/y chroma position.  <a href="#ga29744651709d05d125982e6ca20fcd95">More...</a><br /></td></tr>
<tr class="separator:ga29744651709d05d125982e6ca20fcd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c6c7e3af6c589814d5135561b69980"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga30c6c7e3af6c589814d5135561b69980">avcodec_chroma_pos_to_enum</a> (<a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> xpos, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> ypos)</td></tr>
<tr class="memdesc:ga30c6c7e3af6c589814d5135561b69980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts swscale x/y chroma position to AVChromaLocation.  <a href="#ga30c6c7e3af6c589814d5135561b69980">More...</a><br /></td></tr>
<tr class="separator:ga30c6c7e3af6c589814d5135561b69980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1fbe477c04455cdc7a994090100db4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libswscale_2utils_8c.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#gaaa1fbe477c04455cdc7a994090100db4">avcodec_decode_audio4</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *got_frame_ptr, const <a class="el" href="structAVPacket.html">AVPacket</a> *avpkt)</td></tr>
<tr class="memdesc:gaaa1fbe477c04455cdc7a994090100db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into frame.  <a href="#gaaa1fbe477c04455cdc7a994090100db4">More...</a><br /></td></tr>
<tr class="separator:gaaa1fbe477c04455cdc7a994090100db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac51525b7ad8bca4ced9f3446e96532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libswscale_2utils_8c.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga3ac51525b7ad8bca4ced9f3446e96532">avcodec_decode_video2</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, <a class="el" href="structAVFrame.html">AVFrame</a> *picture, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *got_picture_ptr, const <a class="el" href="structAVPacket.html">AVPacket</a> *avpkt)</td></tr>
<tr class="memdesc:ga3ac51525b7ad8bca4ced9f3446e96532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture.  <a href="#ga3ac51525b7ad8bca4ced9f3446e96532">More...</a><br /></td></tr>
<tr class="separator:ga3ac51525b7ad8bca4ced9f3446e96532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47db1b7f294b9f92684401b9c66a7c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga47db1b7f294b9f92684401b9c66a7c4b">avcodec_decode_subtitle2</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, <a class="el" href="structAVSubtitle.html">AVSubtitle</a> *sub, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *got_sub_ptr, <a class="el" href="structAVPacket.html">AVPacket</a> *avpkt)</td></tr>
<tr class="memdesc:ga47db1b7f294b9f92684401b9c66a7c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a subtitle message.  <a href="#ga47db1b7f294b9f92684401b9c66a7c4b">More...</a><br /></td></tr>
<tr class="separator:ga47db1b7f294b9f92684401b9c66a7c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58bc4bf1e0ac59e27362597e467efff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, const <a class="el" href="structAVPacket.html">AVPacket</a> *avpkt)</td></tr>
<tr class="memdesc:ga58bc4bf1e0ac59e27362597e467efff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply raw packet data as input to a decoder.  <a href="#ga58bc4bf1e0ac59e27362597e467efff3">More...</a><br /></td></tr>
<tr class="separator:ga58bc4bf1e0ac59e27362597e467efff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e6542c4e66d3028668788a1a74217c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c">avcodec_receive_frame</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:ga11e6542c4e66d3028668788a1a74217c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return decoded output data from a decoder.  <a href="#ga11e6542c4e66d3028668788a1a74217c">More...</a><br /></td></tr>
<tr class="separator:ga11e6542c4e66d3028668788a1a74217c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9395cb802a5febf1f00df31497779169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga9395cb802a5febf1f00df31497779169">avcodec_send_frame</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:ga9395cb802a5febf1f00df31497779169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supply a raw video or audio frame to the encoder.  <a href="#ga9395cb802a5febf1f00df31497779169">More...</a><br /></td></tr>
<tr class="separator:ga9395cb802a5febf1f00df31497779169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8eff59cf259747cf0b31563e38ded6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet</a> (<a class="el" href="structAVCodecContext.html">AVCodecContext</a> *avctx, <a class="el" href="structAVPacket.html">AVPacket</a> *avpkt)</td></tr>
<tr class="memdesc:ga5b8eff59cf259747cf0b31563e38ded6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read encoded data from the encoder.  <a href="#ga5b8eff59cf259747cf0b31563e38ded6">More...</a><br /></td></tr>
<tr class="separator:ga5b8eff59cf259747cf0b31563e38ded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8f5b632a03ce83ac8e025894b1fc307a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f5b632a03ce83ac8e025894b1fc307a">&sect;&nbsp;</a></span>AV_INPUT_BUFFER_PADDING_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AV_INPUT_BUFFER_PADDING_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Required number of additionally allocated bytes at the end of the input bitstream for decoding. </p>
<p>This is mainly needed because some optimized bitstream readers read 32 or 64 bit at once and could read over the end.<br />
 Note: If the first 23 bits of the additional bytes are not 0, then damaged MPEG bitstreams could cause overread and segfault. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="decoding_encoding_8c-example.html#a55">decoding_encoding.c</a>, and <a class="el" href="qsvdec_8c-example.html#a79">qsvdec.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="avcodec_8h_source.html#l00738">738</a> of file <a class="el" href="avcodec_8h_source.html">avcodec.h</a>.</p>

<p>Referenced by <a class="el" href="a64multienc_8c_source.html#l00203">a64multi_encode_init()</a>, <a class="el" href="aac__adtstoasc__bsf_8c_source.html#l00038">aac_adtstoasc_filter()</a>, <a class="el" href="aacdec__template_8c_source.html#l03108">aac_decode_frame()</a>, <a class="el" href="libfdk-aacenc_8c_source.html#l00104">aac_encode_init()</a>, <a class="el" href="aac__parser_8c_source.html#l00029">aac_sync()</a>, <a class="el" href="ac3__parser_8c_source.html#l00154">ac3_sync()</a>, <a class="el" href="adpcm_8c_source.html#l00708">adpcm_decode_frame()</a>, <a class="el" href="adpcmenc_8c_source.html#l00063">adpcm_encode_init()</a>, <a class="el" href="alacenc_8c_source.html#l00506">alac_encode_init()</a>, <a class="el" href="aacenc_8c_source.html#l00893">alloc_buffers()</a>, <a class="el" href="alac_8c_source.html#l00485">allocate_buffers()</a>, <a class="el" href="apetag_8c_source.html#l00037">ape_tag_read_field()</a>, <a class="el" href="apngdec_8c_source.html#l00147">apng_read_header()</a>, <a class="el" href="apngenc_8c_source.html#l00081">apng_write_header()</a>, <a class="el" href="apngdec_8c_source.html#l00125">append_extradata()</a>, <a class="el" href="asfdec__f_8c_source.html#l01205">asf_parse_packet()</a>, <a class="el" href="asfdec__f_8c_source.html#l00397">asf_read_stream_properties()</a>, <a class="el" href="atrac3_8c_source.html#l00792">atrac3_decode_init()</a>, <a class="el" href="decoding__encoding_8c_source.html#l00242">audio_decode_example()</a>, <a class="el" href="bitstream__filter_8c_source.html#l00098">av_bitstream_filter_filter()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l00120">av_fast_padded_malloc()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l00132">av_fast_padded_mallocz()</a>, <a class="el" href="avpacket_8c_source.html#l00109">av_grow_packet()</a>, <a class="el" href="avpacket_8c_source.html#l00152">av_packet_from_data()</a>, <a class="el" href="avpacket_8c_source.html#l00382">av_packet_merge_side_data()</a>, <a class="el" href="avpacket_8c_source.html#l00318">av_packet_new_side_data()</a>, <a class="el" href="avpacket_8c_source.html#l00417">av_packet_split_side_data()</a>, <a class="el" href="parser_8c_source.html#l00206">av_parser_change()</a>, <a class="el" href="parser_8c_source.html#l00137">av_parser_parse2()</a>, <a class="el" href="avpacket_8c_source.html#l00101">av_shrink_packet()</a>, <a class="el" href="libavcodec_2options_8c_source.html#l00190">avcodec_copy_context()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l02644">avcodec_decode_subtitle2()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l01809">avcodec_encode_audio2()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l01955">avcodec_encode_video2()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l04152">avcodec_parameters_copy()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l04170">avcodec_parameters_from_context()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l04227">avcodec_parameters_to_context()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l03372">avformat_find_stream_info()</a>, <a class="el" href="avidec_8c_source.html#l00470">avi_read_header()</a>, <a class="el" href="aviobuf_8c_source.html#l01280">avio_close_dyn_buf()</a>, <a class="el" href="avuienc_8c_source.html#l00027">avui_encode_init()</a>, <a class="el" href="libavcodec_2cdxl_8c_source.html#l00239">cdxl_decode_frame()</a>, <a class="el" href="libavcodec_2nuv_8c_source.html#l00117">codec_reinit()</a>, <a class="el" href="cook_8c_source.html#l01053">cook_decode_init()</a>, <a class="el" href="dca__xll_8c_source.html#l01068">copy_to_pbr()</a>, <a class="el" href="mpeg4__unpack__bframes__bsf_8c_source.html#l00075">create_new_buffer()</a>, <a class="el" href="oggparsedaala_8c_source.html#l00078">daala_header()</a>, <a class="el" href="dca__parser_8c_source.html#l00191">dca_parse_params()</a>, <a class="el" href="h264__parse_8c_source.html#l00376">decode_extradata_ps_mp4()</a>, <a class="el" href="libavcodec_24xm_8c_source.html#l00827">decode_frame()</a>, <a class="el" href="libavcodec_2iff_8c_source.html#l00380">decode_init()</a>, <a class="el" href="utvideodec_8c_source.html#l00230">decode_plane()</a>, <a class="el" href="utvideodec_8c_source.html#l00125">decode_plane10()</a>, <a class="el" href="dshow_8c_source.html#l00935">dshow_add_device()</a>, <a class="el" href="dtsdec_8c_source.html#l00032">dts_probe()</a>, <a class="el" href="dvdec_8c_source.html#l00275">dv_decode_video_segment()</a>, <a class="el" href="ffv1enc_8c_source.html#l01093">encode_frame()</a>, <a class="el" href="lclenc_8c_source.html#l00111">encode_init()</a>, <a class="el" href="libavcodec_2iff_8c_source.html#l00200">extract_header()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l03208">ff_alloc_extradata()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l01723">ff_alloc_packet2()</a>, <a class="el" href="avc_8c_source.html#l00164">ff_avc_write_annexb_extradata()</a>, <a class="el" href="parser_8c_source.html#l00251">ff_combine_frame()</a>, <a class="el" href="flac__picture_8c_source.html#l00028">ff_flac_parse_picture()</a>, <a class="el" href="h2645__parse_8c_source.html#l00032">ff_h2645_extract_rbsp()</a>, <a class="el" href="rtpdec__h264_8c_source.html#l00096">ff_h264_parse_sprop_parameter_sets()</a>, <a class="el" href="id3v2_8c_source.html#l01123">ff_id3v2_parse_apic()</a>, <a class="el" href="jpeg2000_8c_source.html#l00448">ff_jpeg2000_init_component()</a>, <a class="el" href="mjpegdec_8c_source.html#l01945">ff_mjpeg_find_marker()</a>, <a class="el" href="mov_8c_source.html#l02243">ff_mov_read_stsd_entries()</a>, <a class="el" href="mpegvideo_8c_source.html#l00483">ff_mpeg_update_thread_context()</a>, <a class="el" href="mpegvideo__enc_8c_source.html#l01844">ff_mpv_encode_picture()</a>, <a class="el" href="mpegts_8c_source.html#l01647">ff_parse_mpeg2_descriptor()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l05497">ff_stream_add_bitstream_filter()</a>, <a class="el" href="vaapi__encode_8c_source.html#l01275">ff_vaapi_encode_init()</a>, <a class="el" href="audiotoolboxenc_8c_source.html#l00232">ffat_init_encoder()</a>, <a class="el" href="ffmdec_8c_source.html#l00280">ffm2_read_header()</a>, <a class="el" href="ffmdec_8c_source.html#l00536">ffm_read_header()</a>, <a class="el" href="oggparsevorbis_8c_source.html#l00223">fixup_vorbis_headers()</a>, <a class="el" href="libavformat_2flacdec_8c_source.html#l00046">flac_read_header()</a>, <a class="el" href="flicvideo_8c_source.html#l00153">flic_decode_frame_8BPP()</a>, <a class="el" href="apngenc_8c_source.html#l00116">flush_packet()</a>, <a class="el" href="libavformat_2flvdec_8c_source.html#l00750">flv_queue_extradata()</a>, <a class="el" href="libavformat_2flvenc_8c_source.html#l00872">flv_write_packet()</a>, <a class="el" href="g2meet_8c_source.html#l01165">g2m_init_buffers()</a>, <a class="el" href="qsvenc__hevc_8c_source.html#l00052">generate_fake_vps()</a>, <a class="el" href="h264__mp4toannexb__bsf_8c_source.html#l00140">h264_mp4toannexb_init()</a>, <a class="el" href="mpegts_8c_source.html#l02480">handle_packets()</a>, <a class="el" href="hevc__mp4toannexb__bsf_8c_source.html#l00039">hevc_extradata_to_annexb()</a>, <a class="el" href="rtpdec__hevc_8c_source.html#l00130">hevc_parse_sdp_line()</a>, <a class="el" href="hls_8c_source.html#l00922">id3_has_changed_values()</a>, <a class="el" href="libavformat_2iff_8c_source.html#l00410">iff_read_header()</a>, <a class="el" href="imc_8c_source.html#l01013">imc_decode_frame()</a>, <a class="el" href="libopenjpegenc_8c_source.html#l00083">info_callback()</a>, <a class="el" href="crystalhd_8c_source.html#l00329">init_bsf()</a>, <a class="el" href="tests_2movenc_8c_source.html#l00177">init_fps()</a>, <a class="el" href="libavformat_2jacosubdec_8c_source.html#l00156">jacosub_read_header()</a>, <a class="el" href="g2meet_8c_source.html#l00283">jpg_decode_data()</a>, <a class="el" href="libavcodec_2aacdec_8c_source.html#l00281">latm_decode_audio_specific_config()</a>, <a class="el" href="libkvazaar_8c_source.html#l00047">libkvazaar_init()</a>, <a class="el" href="libopusenc_8c_source.html#l00237">libopus_encode_init()</a>, <a class="el" href="libvorbisenc_8c_source.html#l00195">libvorbis_encode_init()</a>, <a class="el" href="libx265_8c_source.html#l00078">libx265_encode_init()</a>, <a class="el" href="doc_2examples_2qsvdec_8c_source.html#l00306">main()</a>, <a class="el" href="matroskadec_8c_source.html#l01975">matroska_parse_tracks()</a>, <a class="el" href="mov_8c_source.html#l01426">mov_read_atom_into_extradata()</a>, <a class="el" href="mov_8c_source.html#l02338">mov_read_stsd()</a>, <a class="el" href="mov_8c_source.html#l02531">mov_read_stsz()</a>, <a class="el" href="mov_8c_source.html#l01604">mov_read_wave()</a>, <a class="el" href="mov_8c_source.html#l01411">mov_realloc_extradata()</a>, <a class="el" href="mov_8c_source.html#l02036">mov_rewrite_dvd_sub_extradata()</a>, <a class="el" href="movtextenc_8c_source.html#l00152">mov_text_encode_init()</a>, <a class="el" href="movenc_8c_source.html#l00750">mov_write_dvc1_structs()</a>, <a class="el" href="movenc_8c_source.html#l05047">mov_write_single_packet()</a>, <a class="el" href="mp3__header__decompress__bsf_8c_source.html#l00029">mp3_header_decompress()</a>, <a class="el" href="libavformat_2mpc8_8c_source.html#l00133">mpc8_parse_seektable()</a>, <a class="el" href="mpegts_8c_source.html#l01007">mpegts_push_data()</a>, <a class="el" href="mxg_8c_source.html#l00100">mxg_update_cache()</a>, <a class="el" href="libavformat_2hevc_8c_source.html#l00645">nal_unit_extract_rbsp()</a>, <a class="el" href="mpegts_8c_source.html#l00888">new_pes_packet()</a>, <a class="el" href="nvenc_8c_source.html#l01138">nvenc_setup_extradata()</a>, <a class="el" href="oggdec_8c_source.html#l00286">ogg_new_buf()</a>, <a class="el" href="oggdec_8c_source.html#l00244">ogg_new_stream()</a>, <a class="el" href="oggdec_8c_source.html#l00317">ogg_read_page()</a>, <a class="el" href="oggdec_8c_source.html#l00067">ogg_save()</a>, <a class="el" href="oggparseogm_8c_source.html#l00038">ogm_header()</a>, <a class="el" href="omx_8c_source.html#l00721">omx_encode_frame()</a>, <a class="el" href="omx_8c_source.html#l00625">omx_encode_init()</a>, <a class="el" href="avpacket_8c_source.html#l00071">packet_alloc()</a>, <a class="el" href="rtpdec__latm_8c_source.html#l00092">parse_fmtp_config()</a>, <a class="el" href="rtpdec__xiph_8c_source.html#l00225">parse_packed_headers()</a>, <a class="el" href="asfdec__o_8c_source.html#l00692">parse_video_info()</a>, <a class="el" href="libavformat_24xm_8c_source.html#l00092">parse_vtrk()</a>, <a class="el" href="pcx_8c_source.html#l00066">pcx_decode_frame()</a>, <a class="el" href="qsvenc_8c_source.html#l00543">qsv_retrieve_enc_params()</a>, <a class="el" href="rtpdec__qt_8c_source.html#l00042">qt_rtp_parse_packet()</a>, <a class="el" href="rdt_8c_source.html#l00392">rdt_parse_b64buf()</a>, <a class="el" href="id3v2_8c_source.html#l00587">read_apic()</a>, <a class="el" href="libavformat_2anm_8c_source.html#l00079">read_header()</a>, <a class="el" href="cafdec_8c_source.html#l00099">read_kuki_chunk()</a>, <a class="el" href="libavformat_2jvdec_8c_source.html#l00163">read_packet()</a>, <a class="el" href="mpegts_8c_source.html#l00935">read_sl_header()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l02494">recode_subtitle()</a>, <a class="el" href="rmdec_8c_source.html#l00127">rm_read_audio_stream_info()</a>, <a class="el" href="hevcdsp__template_8c_source.html#l00330">sao_edge_filter()</a>, <a class="el" href="hevc__filter_8c_source.html#l00246">sao_filter_CTB()</a>, <a class="el" href="videotoolboxenc_8c_source.html#l00401">set_extradata()</a>, <a class="el" href="shortendec_8c_source.html#l00028">shn_probe()</a>, <a class="el" href="shorten_8c_source.html#l00498">shorten_decode_frame()</a>, <a class="el" href="spdifenc_8c_source.html#l00496">spdif_write_packet()</a>, <a class="el" href="libopenh264enc_8c_source.html#l00092">svc_encode_init()</a>, <a class="el" href="svq3_8c_source.html#l01023">svq3_decode_slice_header()</a>, <a class="el" href="libavformat_2takdec_8c_source.html#l00051">tak_read_header()</a>, <a class="el" href="oggparsetheora_8c_source.html#l00038">theora_header()</a>, <a class="el" href="tiff_8c_source.html#l00450">tiff_unpack_fax()</a>, <a class="el" href="utvideoenc_8c_source.html#l00060">utvideo_encode_init()</a>, <a class="el" href="libavcodec_2vc1dec_8c_source.html#l00622">vc1_decode_frame()</a>, <a class="el" href="libavcodec_2vc1dec_8c_source.html#l00422">vc1_decode_init()</a>, <a class="el" href="vfwcap_8c_source.html#l00245">vfw_read_header()</a>, <a class="el" href="decoding__encoding_8c_source.html#l00534">video_decode_example()</a>, <a class="el" href="xcbgrab_8c_source.html#l00190">wait_frame()</a>, <a class="el" href="wmadec_8c_source.html#l00807">wma_decode_superframe()</a>, <a class="el" href="wmv2enc_8c_source.html#l00055">wmv2_encode_init()</a>, <a class="el" href="ffv1enc_8c_source.html#l00391">write_extradata()</a>, <a class="el" href="wavpack_8c_source.html#l00288">wv_get_value_float()</a>, and <a class="el" href="libx264_8c_source.html#l00452">X264_init()</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga352363bce7d3ed82c101b3bc001d1c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352363bce7d3ed82c101b3bc001d1c16">&sect;&nbsp;</a></span>AVDiscard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16a93d0436f7651b58debe3f995e2582dcd"></a>AVDISCARD_NONE&#160;</td><td class="fielddoc"><p>discard nothing </p>
</td></tr>
<tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16a81453d8c452e8ee794daf7fde1c80b5b"></a>AVDISCARD_DEFAULT&#160;</td><td class="fielddoc"><p>discard useless packets like 0 size packets in avi </p>
</td></tr>
<tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16ac5a5a87ffcd6fb2362ac18449d29bde8"></a>AVDISCARD_NONREF&#160;</td><td class="fielddoc"><p>discard all non reference </p>
</td></tr>
<tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16a776541ad00a4f13c3fdcd363988bffb3"></a>AVDISCARD_BIDIR&#160;</td><td class="fielddoc"><p>discard all bidirectional frames </p>
</td></tr>
<tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16aabee31ca5c7c140d3a84b848164eeaf8"></a>AVDISCARD_NONINTRA&#160;</td><td class="fielddoc"><p>discard all non intra frames </p>
</td></tr>
<tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16a31c8164477d9f571f82003065d2ab6f1"></a>AVDISCARD_NONKEY&#160;</td><td class="fielddoc"><p>discard all frames except keyframes </p>
</td></tr>
<tr><td class="fieldname"><a id="gga352363bce7d3ed82c101b3bc001d1c16a07517e3890ba7e19a612945483dc066a"></a>AVDISCARD_ALL&#160;</td><td class="fielddoc"><p>discard all </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="avcodec_8h_source.html#l00782">782</a> of file <a class="el" href="avcodec_8h_source.html">avcodec.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga19a0ca553277f019dd5b0fec6e1f9dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a0ca553277f019dd5b0fec6e1f9dca">&sect;&nbsp;</a></span>avcodec_find_decoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVCodec.html">AVCodec</a>* avcodec_find_decoder </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a registered decoder with a matching codec ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>AVCodecID of the requested decoder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A decoder if one was found, NULL otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="decoding_encoding_8c-example.html#a56">decoding_encoding.c</a>, <a class="el" href="demuxing_decoding_8c-example.html#a60">demuxing_decoding.c</a>, <a class="el" href="transcode_aac_8c-example.html#a12">transcode_aac.c</a>, and <a class="el" href="transcoding_8c-example.html#a24">transcoding.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l03129">3129</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="ffmpeg__opt_8c_source.html#l00651">add_input_streams()</a>, <a class="el" href="decoding__encoding_8c_source.html#l00242">audio_decode_example()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l03148">avcodec_get_name()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l01242">avcodec_open2()</a>, <a class="el" href="decoder__targeted_8c_source.html#l00060">AVCodecInitialize()</a>, <a class="el" href="ffmpeg__opt_8c_source.html#l00633">choose_decoder()</a>, <a class="el" href="dshow_8c_source.html#l00321">dshow_cycle_formats()</a>, <a class="el" href="lavfutils_8c_source.html#l00024">ff_load_image()</a>, <a class="el" href="cmdutils_8c_source.html#l02102">filter_codec_opts()</a>, <a class="el" href="ffmpeg__opt_8c_source.html#l00604">find_codec_or_die()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l00165">find_decoder()</a>, <a class="el" href="avrndec_8c_source.html#l00035">init()</a>, <a class="el" href="api-flac-test_8c_source.html#l00240">main()</a>, <a class="el" href="demuxing__decoding_8c_source.html#l00149">open_codec_context()</a>, <a class="el" href="transcode__aac_8c_source.html#l00061">open_input_file()</a>, <a class="el" href="src__movie_8c_source.html#l00152">open_stream()</a>, <a class="el" href="api-seek-test_8c_source.html#l00174">seek_test()</a>, <a class="el" href="cmdutils_8c_source.html#l01592">show_codecs()</a>, <a class="el" href="smvjpegdec_8c_source.html#l00092">smvjpeg_decode_init()</a>, <a class="el" href="ffplay_8c_source.html#l02562">stream_component_open()</a>, <a class="el" href="tdsc_8c_source.html#l00091">tdsc_init()</a>, <a class="el" href="api-codec-param-test_8c_source.html#l00030">try_decode_video_frame()</a>, <a class="el" href="api-band-test_8c_source.html#l00067">video_decode()</a>, and <a class="el" href="decoding__encoding_8c_source.html#l00534">video_decode_example()</a>.</p>

</div>
</div>
<a id="ga776f2359007e8457799503068419e791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga776f2359007e8457799503068419e791">&sect;&nbsp;</a></span>avcodec_find_decoder_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVCodec.html">AVCodec</a>* avcodec_find_decoder_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a registered decoder with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the requested decoder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A decoder if one was found, NULL otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="qsvdec_8c-example.html#a74">qsvdec.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l03134">3134</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="ffmpeg__opt_8c_source.html#l00604">find_codec_or_die()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l00189">find_probe_decoder()</a>, <a class="el" href="doc_2examples_2qsvdec_8c_source.html#l00306">main()</a>, <a class="el" href="cmdutils_8c_source.html#l01855">show_help_codec()</a>, <a class="el" href="ffplay_8c_source.html#l02562">stream_component_open()</a>, and <a class="el" href="v4l2_8c_source.html#l00817">v4l2_read_header()</a>.</p>

</div>
</div>
<a id="ga09dee227d3666720eff1f6913d11699d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09dee227d3666720eff1f6913d11699d">&sect;&nbsp;</a></span>avcodec_default_get_buffer2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_default_get_buffer2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default callback for <a class="el" href="structAVCodecContext.html#aef79333a4c6abf1628c55d75ec82bede" title="This callback is called at the beginning of each frame to get data buffer(s) for it. ">AVCodecContext.get_buffer2()</a>. </p>
<p>It is made public so it can be called by custom <a class="el" href="vda__h264__dec_8c.html#a515ddfbff6c1cd0d2e0b89e0c7d5b9a8">get_buffer2()</a> implementations for decoders without AV_CODEC_CAP_DR1 set. </p>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l00723">723</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="mpegpicture_8c_source.html#l00098">alloc_frame_buffer()</a>, <a class="el" href="pthread__frame_8c_source.html#l00849">ff_thread_release_buffer()</a>, <a class="el" href="ffmpeg_8c_source.html#l02724">get_buffer()</a>, <a class="el" href="libavcodec_2options_8c_source.html#l00092">init_context_defaults()</a>, <a class="el" href="pthread__frame_8c_source.html#l00310">submit_packet()</a>, and <a class="el" href="pthread__frame_8c_source.html#l00757">thread_get_buffer_internal()</a>.</p>

</div>
</div>
<a id="gaad92aaeee369795273fc6cfc6ef3b189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad92aaeee369795273fc6cfc6ef3b189">&sect;&nbsp;</a></span>avcodec_get_edge_width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libswscale_2utils_8c.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> unsigned avcodec_get_edge_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the amount of padding in pixels which the get_buffer callback must provide around the edge of the image for codecs which do not have the CODEC_FLAG_EMU_EDGE flag. </p>
<dl class="section return"><dt>Returns</dt><dd>Required padding in pixels.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer needed </dd></dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l00194">194</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

</div>
</div>
<a id="ga48432a3760eec9fce0f0ef7b298859f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48432a3760eec9fce0f0ef7b298859f1">&sect;&nbsp;</a></span>avcodec_align_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> avcodec_align_dimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding. </p>
<p>May only be used if a codec with AV_CODEC_CAP_DR1 has been opened. </p>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l00432">432</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

</div>
</div>
<a id="ga34e3269dc1b9e2c98e9371241722e7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e3269dc1b9e2c98e9371241722e7e2">&sect;&nbsp;</a></span>avcodec_align_dimensions2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> avcodec_align_dimensions2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>linesize_align</em>[AV_NUM_DATA_POINTERS]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i]. </p>
<p>May only be used if a codec with AV_CODEC_CAP_DR1 has been opened. </p>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l00260">260</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="libavcodec_2utils_8c_source.html#l00432">avcodec_align_dimensions()</a>, and <a class="el" href="libavcodec_2utils_8c_source.html#l00506">update_frame_pool()</a>.</p>

</div>
</div>
<a id="ga29744651709d05d125982e6ca20fcd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29744651709d05d125982e6ca20fcd95">&sect;&nbsp;</a></span>avcodec_enum_to_chroma_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_enum_to_chroma_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>ypos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#a1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts AVChromaLocation to swscale x/y chroma position. </p>
<p>The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xpos</td><td>horizontal chroma sample position </td></tr>
    <tr><td class="paramname">ypos</td><td>vertical chroma sample position </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l00447">447</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="libavcodec_2utils_8c_source.html#l00459">avcodec_chroma_pos_to_enum()</a>, and <a class="el" href="matroskaenc_8c_source.html#l00809">mkv_write_video_color()</a>.</p>

</div>
</div>
<a id="ga30c6c7e3af6c589814d5135561b69980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30c6c7e3af6c589814d5135561b69980">&sect;&nbsp;</a></span>avcodec_chroma_pos_to_enum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a> avcodec_chroma_pos_to_enum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts swscale x/y chroma position to AVChromaLocation. </p>
<p>The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xpos</td><td>horizontal chroma sample position </td></tr>
    <tr><td class="paramname">ypos</td><td>vertical chroma sample position </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l00459">459</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="matroskadec_8c_source.html#l01829">mkv_parse_video_color()</a>.</p>

</div>
</div>
<a id="gaaa1fbe477c04455cdc7a994090100db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1fbe477c04455cdc7a994090100db4">&sect;&nbsp;</a></span>avcodec_decode_audio4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libswscale_2utils_8c.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_decode_audio4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>got_frame_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVPacket.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into frame. </p>
<p>Some decoders may support multiple frames in a single <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a>. Such decoders would then just decode the first frame and the return value would be less than the packet size. In this case, avcodec_decode_audio4 has to be called again with an <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a> containing the remaining data in order to decode the second frame, etc... Even if no frames are returned, the packet needs to be fed to the decoder with remaining data until it is completely consumed or an error occurs.</p>
<p>Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt-&gt;data set to NULL and avpkt-&gt;size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with AV_CODEC_CAP_DELAY, then no samples will be returned.</p>
<dl class="section warning"><dt>Warning</dt><dd>The input buffer, avpkt-&gt;data must be AV_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a> MUST have been opened with <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a> before packets may be fed to the decoder.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>the codec context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frame</td><td>The <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> in which to store decoded audio samples. The decoder will allocate a buffer for the decoded frame by calling the <a class="el" href="structAVCodecContext.html#aef79333a4c6abf1628c55d75ec82bede" title="This callback is called at the beginning of each frame to get data buffer(s) for it. ">AVCodecContext.get_buffer2()</a> callback. When <a class="el" href="structAVCodecContext.html#ab16d1e0c729a7b63d918d5ec027ba064" title="If non-zero, the decoded audio and video frames returned from avcodec_decode_video2() and avcodec_dec...">AVCodecContext.refcounted_frames</a> is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using <a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108" title="Unreference all the buffers referenced by frame and reset the frame fields. ">av_frame_unref()</a> when the frame is no longer needed. The caller may safely write to the frame if <a class="el" href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a" title="Check if the frame data is writable. ">av_frame_is_writable()</a> returns 1. When <a class="el" href="structAVCodecContext.html#ab16d1e0c729a7b63d918d5ec027ba064" title="If non-zero, the decoded audio and video frames returned from avcodec_decode_video2() and avcodec_dec...">AVCodecContext.refcounted_frames</a> is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">got_frame_ptr</td><td>Zero if no frame could be decoded, otherwise it is non-zero. Note that this field being set to zero does not mean that an error has occurred. For decoders with AV_CODEC_CAP_DELAY set, no given decode call is guaranteed to produce a frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a> containing the input buffer. At least avpkt-&gt;data and avpkt-&gt;size should be set. Some decoders might also require additional fields to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative error code is returned if an error occurred during decoding, otherwise the number of bytes consumed from the input <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a> is returned.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3" title="Supply raw packet data as input to a decoder. ">avcodec_send_packet()</a> and <a class="el" href="group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c" title="Return decoded output data from a decoder. ">avcodec_receive_frame()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="decoding_encoding_8c-example.html#a58">decoding_encoding.c</a>, <a class="el" href="demuxing_decoding_8c-example.html#a43">demuxing_decoding.c</a>, <a class="el" href="filtering_audio_8c-example.html#a83">filtering_audio.c</a>, <a class="el" href="transcode_aac_8c-example.html#a74">transcode_aac.c</a>, and <a class="el" href="transcoding_8c-example.html#a122">transcoding.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02317">2317</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="decoding__encoding_8c_source.html#l00242">audio_decode_example()</a>, <a class="el" href="transcode__aac_8c_source.html#l00335">decode_audio_frame()</a>, <a class="el" href="demuxing__decoding_8c_source.html#l00064">decode_packet()</a>, <a class="el" href="ffplay_8c_source.html#l00559">decoder_decode_frame()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l02768">do_decode()</a>, <a class="el" href="filtering__audio_8c_source.html#l00211">main()</a>, <a class="el" href="src__movie_8c_source.html#l00466">movie_push_frame()</a>, <a class="el" href="ffprobe_8c_source.html#l01982">process_frame()</a>, <a class="el" href="api-flac-test_8c_source.html#l00108">run_test()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00032">wrap()</a>.</p>

</div>
</div>
<a id="ga3ac51525b7ad8bca4ced9f3446e96532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ac51525b7ad8bca4ced9f3446e96532">&sect;&nbsp;</a></span>avcodec_decode_video2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libswscale_2utils_8c.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_decode_video2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>picture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>got_picture_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVPacket.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture. </p>
<p>Some decoders may support multiple frames in a single <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a>, such decoders would then just decode the first frame.</p>
<dl class="section warning"><dt>Warning</dt><dd>The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</dd>
<dd>
The end of the input buffer buf should be set to 0 to ensure that no overreading happens for damaged MPEG streams.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay between input and output, these need to be fed with avpkt-&gt;data=NULL, avpkt-&gt;size=0 at the end to return the remaining frames.</dd>
<dd>
The <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a> MUST have been opened with <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a> before packets may be fed to the decoder.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>the codec context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">picture</td><td>The <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> in which the decoded video frame will be stored. Use <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values. ">av_frame_alloc()</a> to get an <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a>. The codec will allocate memory for the actual bitmap by calling the <a class="el" href="structAVCodecContext.html#aef79333a4c6abf1628c55d75ec82bede" title="This callback is called at the beginning of each frame to get data buffer(s) for it. ">AVCodecContext.get_buffer2()</a> callback. When <a class="el" href="structAVCodecContext.html#ab16d1e0c729a7b63d918d5ec027ba064" title="If non-zero, the decoded audio and video frames returned from avcodec_decode_video2() and avcodec_dec...">AVCodecContext.refcounted_frames</a> is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using <a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108" title="Unreference all the buffers referenced by frame and reset the frame fields. ">av_frame_unref()</a> when the frame is no longer needed. The caller may safely write to the frame if <a class="el" href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a" title="Check if the frame data is writable. ">av_frame_is_writable()</a> returns 1. When <a class="el" href="structAVCodecContext.html#ab16d1e0c729a7b63d918d5ec027ba064" title="If non-zero, the decoded audio and video frames returned from avcodec_decode_video2() and avcodec_dec...">AVCodecContext.refcounted_frames</a> is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a> containing the input buffer. You can create such packet with <a class="el" href="group__lavc__packet.html#gac9cb9756175b96e7441575803757fb73" title="Initialize optional fields of a packet with default values. ">av_init_packet()</a> and by then setting data and size, some decoders might in addition need other fields like flags&amp;AV_PKT_FLAG_KEY. All decoders are designed to use the least fields possible. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">got_picture_ptr</td><td>Zero if no frame could be decompressed, otherwise, it is nonzero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On error a negative value is returned, otherwise the number of bytes used or zero if no frame could be decompressed.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3" title="Supply raw packet data as input to a decoder. ">avcodec_send_packet()</a> and <a class="el" href="group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c" title="Return decoded output data from a decoder. ">avcodec_receive_frame()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="decoding_encoding_8c-example.html#a88">decoding_encoding.c</a>, <a class="el" href="demuxing_decoding_8c-example.html#a33">demuxing_decoding.c</a>, <a class="el" href="filtering_video_8c-example.html#a77">filtering_video.c</a>, <a class="el" href="qsvdec_8c-example.html#a51">qsvdec.c</a>, and <a class="el" href="transcoding_8c-example.html#a121">transcoding.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02214">2214</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="api-seek-test_8c_source.html#l00075">compute_crc_of_packets()</a>, <a class="el" href="avrndec_8c_source.html#l00100">decode_frame()</a>, <a class="el" href="demuxing__decoding_8c_source.html#l00064">decode_packet()</a>, <a class="el" href="decoding__encoding_8c_source.html#l00506">decode_write_frame()</a>, <a class="el" href="ffplay_8c_source.html#l00559">decoder_decode_frame()</a>, <a class="el" href="libavcodec_2utils_8c_source.html#l02768">do_decode()</a>, <a class="el" href="lavfutils_8c_source.html#l00024">ff_load_image()</a>, <a class="el" href="filtering__video_8c_source.html#l00205">main()</a>, <a class="el" href="src__movie_8c_source.html#l00466">movie_push_frame()</a>, <a class="el" href="ffprobe_8c_source.html#l01982">process_frame()</a>, <a class="el" href="smvjpegdec_8c_source.html#l00145">smvjpeg_decode_frame()</a>, <a class="el" href="tdsc_8c_source.html#l00341">tdsc_decode_jpeg_tile()</a>, <a class="el" href="api-codec-param-test_8c_source.html#l00030">try_decode_video_frame()</a>, <a class="el" href="api-band-test_8c_source.html#l00067">video_decode()</a>, <a class="el" href="api-h264-test_8c_source.html#l00032">video_decode_example()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00041">wrap()</a>.</p>

</div>
</div>
<a id="ga47db1b7f294b9f92684401b9c66a7c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47db1b7f294b9f92684401b9c66a7c4b">&sect;&nbsp;</a></span>avcodec_decode_subtitle2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_decode_subtitle2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVSubtitle.html">AVSubtitle</a> *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> *&#160;</td>
          <td class="paramname"><em>got_sub_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVPacket.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a subtitle message. </p>
<p>Return a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for simplicity, because the performance difference is expect to be negligible and reusing a get_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.</p>
<p>Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt-&gt;data set to NULL and avpkt-&gt;size set to 0 until it stops returning subtitles. It is safe to flush even those decoders that are not marked with CODEC_CAP_DELAY, then no subtitles will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a> MUST have been opened with <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a> before packets may be fed to the decoder.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>the codec context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sub</td><td>The Preallocated <a class="el" href="structAVSubtitle.html">AVSubtitle</a> in which the decoded subtitle will be stored, must be freed with avsubtitle_free if *got_sub_ptr is set. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">got_sub_ptr</td><td>Zero if no subtitle could be decompressed, otherwise, it is nonzero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a> containing the input buffer. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02644">2644</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="decoder__targeted_8c_source.html#l00060">AVCodecInitialize()</a>, <a class="el" href="ffplay_8c_source.html#l00559">decoder_decode_frame()</a>, <a class="el" href="ffprobe_8c_source.html#l01982">process_frame()</a>, <a class="el" href="ffmpeg_8c_source.html#l02388">transcode_subtitles()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l02937">try_decode_frame()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00050">wrap()</a>.</p>

</div>
</div>
<a id="ga58bc4bf1e0ac59e27362597e467efff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58bc4bf1e0ac59e27362597e467efff3">&sect;&nbsp;</a></span>avcodec_send_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_send_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVPacket.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply raw packet data as input to a decoder. </p>
<p>Internally, this call will copy relevant <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a> fields, which can influence decoding per-packet, and apply them when the packet is actually decoded. (For example <a class="el" href="structAVCodecContext.html#af869b808363998c80adf7df6a944a5a6" title="Skip decoding for selected frames. ">AVCodecContext.skip_frame</a>, which might direct the decoder to drop the frame contained by the packet sent with this function.)</p>
<dl class="section warning"><dt>Warning</dt><dd>The input buffer, avpkt-&gt;data must be AV_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.</dd>
<dd>
Do not mix this API with the legacy API (like <a class="el" href="group__lavc__decoding.html#ga3ac51525b7ad8bca4ced9f3446e96532" title="Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture. ">avcodec_decode_video2()</a>) on the same <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a>. It will return unexpected results now or in future libavcodec versions.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a> MUST have been opened with <a class="el" href="group__lavc__core.html#ga11f785a188d7d9df71621001465b0f1d">avcodec_open2()</a> before packets may be fed to the decoder.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>codec context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avpkt</td><td>The input <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a>. Usually, this will be a single video frame, or several complete audio frames. Ownership of the packet remains with the caller, and the decoder will not write to the packet. The decoder may create a reference to the packet data (or copy it if the packet is not reference-counted). Unlike with older APIs, the packet is always fully consumed, and if it contains multiple frames (e.g. some audio codecs), will require you to call <a class="el" href="group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c" title="Return decoded output data from a decoder. ">avcodec_receive_frame()</a> multiple times afterwards before you can send a new packet. It can be NULL (or an <a class="el" href="structAVPacket.html" title="This structure stores compressed data. ">AVPacket</a> with data set to NULL and size set to 0); in this case, it is considered a flush packet, which signals the end of the stream. Sending the first flush packet will return success. Subsequent ones are unnecessary and will return AVERROR_EOF. If the decoder still has frames buffered, it will return them after sending a flush packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code: <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EAGAIN)</a>: input is not accepted right now - the packet must be resent after trying to read output AVERROR_EOF: the decoder has been flushed, and no new packets can be sent to it (also returned if more than 1 flush packet is sent) <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EINVAL)</a>: codec not opened, it is an encoder, or requires flush <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(ENOMEM)</a>: failed to add packet to internal queue, or similar other errors: legitimate decoding errors </dd></dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02832">2832</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="ffmpeg_8c_source.html#l02061">decode()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l02937">try_decode_frame()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00081">wrap()</a>.</p>

</div>
</div>
<a id="ga11e6542c4e66d3028668788a1a74217c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e6542c4e66d3028668788a1a74217c">&sect;&nbsp;</a></span>avcodec_receive_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_receive_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return decoded output data from a decoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avctx</td><td>codec context </td></tr>
    <tr><td class="paramname">frame</td><td>This will be set to a reference-counted video or audio frame (depending on the decoder type) allocated by the decoder. Note that the function will always call av_frame_unref(frame) before doing anything else.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0: success, a frame was returned <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EAGAIN)</a>: output is not available right now - user must try to send new input AVERROR_EOF: the decoder has been fully flushed, and there will be no more output frames <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EINVAL)</a>: codec not opened, or it is an encoder other negative values: legitimate decoding errors </dd></dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02881">2881</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="ffmpeg_8c_source.html#l02061">decode()</a>, <a class="el" href="libavformat_2utils_8c_source.html#l02937">try_decode_frame()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00086">wrap()</a>.</p>

</div>
</div>
<a id="ga9395cb802a5febf1f00df31497779169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9395cb802a5febf1f00df31497779169">&sect;&nbsp;</a></span>avcodec_send_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_send_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supply a raw video or audio frame to the encoder. </p>
<p>Use <a class="el" href="group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6" title="Read encoded data from the encoder. ">avcodec_receive_packet()</a> to retrieve buffered output packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">avctx</td><td>codec context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame</td><td><a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> containing the raw audio or video frame to be encoded. Ownership of the frame remains with the caller, and the encoder will not write to the frame. The encoder may create a reference to the frame data (or copy it if the frame is not reference-counted). It can be NULL, in which case it is considered a flush packet. This signals the end of the stream. If the encoder still has packets buffered, it will return them after this call. Once flushing mode has been entered, additional flush packets are ignored, and sending frames will return AVERROR_EOF.</td></tr>
  </table>
  </dd>
</dl>
<p>For audio: If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame can have any number of samples. If it is not set, frame-&gt;nb_samples must be equal to avctx-&gt;frame_size for all frames except the last. The final frame may be smaller than avctx-&gt;frame_size. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code: <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EAGAIN)</a>: input is not accepted right now - the frame must be resent after trying to read output packets AVERROR_EOF: the encoder has been flushed, and no new frames can be sent to it <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EINVAL)</a>: codec not opened, refcounted_frames not set, it is a decoder, or requires flush <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(ENOMEM)</a>: failed to add packet to internal queue, or similar other errors: legitimate decoding errors </dd></dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02962">2962</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="ffmpeg_8c_source.html#l00870">do_audio_out()</a>, <a class="el" href="ffmpeg_8c_source.html#l01013">do_video_out()</a>, <a class="el" href="ffmpeg_8c_source.html#l01815">flush_encoders()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00091">wrap()</a>.</p>

</div>
</div>
<a id="ga5b8eff59cf259747cf0b31563e38ded6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8eff59cf259747cf0b31563e38ded6">&sect;&nbsp;</a></span>avcodec_receive_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> avcodec_receive_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVCodecContext.html">AVCodecContext</a> *&#160;</td>
          <td class="paramname"><em>avctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVPacket.html">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>avpkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read encoded data from the encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avctx</td><td>codec context </td></tr>
    <tr><td class="paramname">avpkt</td><td>This will be set to a reference-counted packet allocated by the encoder. Note that the function will always call av_frame_unref(frame) before doing anything else. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code: <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EAGAIN)</a>: output is not available right now - user must try to send input AVERROR_EOF: the encoder has been fully flushed, and there will be no more output packets <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(EINVAL)</a>: codec not opened, or it is an encoder other errors: legitimate decoding errors </dd></dl>

<p>Definition at line <a class="el" href="libavcodec_2utils_8c_source.html#l02992">2992</a> of file <a class="el" href="libavcodec_2utils_8c_source.html">utils.c</a>.</p>

<p>Referenced by <a class="el" href="ffmpeg_8c_source.html#l00870">do_audio_out()</a>, <a class="el" href="ffmpeg_8c_source.html#l01013">do_video_out()</a>, <a class="el" href="ffmpeg_8c_source.html#l01815">flush_encoders()</a>, and <a class="el" href="libavcodec_2aarch64_2neontest_8c_source.html#l00096">wrap()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 2 2017 22:49:06 for FFmpeg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
