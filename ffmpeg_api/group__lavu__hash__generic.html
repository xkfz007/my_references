<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: Generic Hashing API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generic Hashing API<div class="ingroups"><a class="el" href="group__lavu.html">libavutil</a> &raquo; <a class="el" href="group__lavu__crypto.html">Crypto and Hashing</a> &raquo; <a class="el" href="group__lavu__hash.html">Hash Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstraction layer for all hash functions supported by libavutil.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hash_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html">hash.h</a></td></tr>
<tr class="memdesc:hash_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic hashing API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaff5173f8837eb3afbd20b52528833d72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72">AV_HASH_MAX_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:gaff5173f8837eb3afbd20b52528833d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value that <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a> will currently return.  <a href="#gaff5173f8837eb3afbd20b52528833d72">More...</a><br /></td></tr>
<tr class="separator:gaff5173f8837eb3afbd20b52528833d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> **<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>, const char *<a class="el" href="checkasm_8c.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>)</td></tr>
<tr class="memdesc:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a hash context for the algorithm specified by name.  <a href="#gad1e018687f3a0e9baf3fb6d3af0dd10b">More...</a><br /></td></tr>
<tr class="separator:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62537bbcf4cae67bbb33f3fa4f4329bf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga62537bbcf4cae67bbb33f3fa4f4329bf">av_hash_names</a> (<a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> i)</td></tr>
<tr class="memdesc:ga62537bbcf4cae67bbb33f3fa4f4329bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of available hash algorithms.  <a href="#ga62537bbcf4cae67bbb33f3fa4f4329bf">More...</a><br /></td></tr>
<tr class="separator:ga62537bbcf4cae67bbb33f3fa4f4329bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5952d21d5503ac307fbaa5d05a3d93ca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga5952d21d5503ac307fbaa5d05a3d93ca">av_hash_get_name</a> (const struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>)</td></tr>
<tr class="memdesc:ga5952d21d5503ac307fbaa5d05a3d93ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the algorithm corresponding to the given hash context.  <a href="#ga5952d21d5503ac307fbaa5d05a3d93ca">More...</a><br /></td></tr>
<tr class="separator:ga5952d21d5503ac307fbaa5d05a3d93ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf8f94e3ebf73f838d017f83352d880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size</a> (const struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>)</td></tr>
<tr class="memdesc:ga8bf8f94e3ebf73f838d017f83352d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the resulting hash value in bytes.  <a href="#ga8bf8f94e3ebf73f838d017f83352d880">More...</a><br /></td></tr>
<tr class="separator:ga8bf8f94e3ebf73f838d017f83352d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>)</td></tr>
<tr class="memdesc:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reset a hash context.  <a href="#ga84ef872a731eb5c2637ddcd0f0976bca">More...</a><br /></td></tr>
<tr class="separator:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>, const <a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *<a class="el" href="avxsynth__c_8h.html#a67caf60f8ec76e0adc7b693bfb651b66">src</a>, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="vorbis__enc__data_8h.html#afed088663f8704004425cdae2120b9b3">len</a>)</td></tr>
<tr class="memdesc:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a hash context with additional data.  <a href="#gac6a467ff60cb5080b56e818e7b8adb4a">More...</a><br /></td></tr>
<tr class="separator:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>, <a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *dst)</td></tr>
<tr class="memdesc:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and compute the actual hash value.  <a href="#gaeff9a69f576f8f94e33a0b43a08baa70">More...</a><br /></td></tr>
<tr class="separator:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e1a59bf9c2076eda5884e89249af12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga65e1a59bf9c2076eda5884e89249af12">av_hash_final_bin</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>, <a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *dst, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="hash_8c.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="memdesc:ga65e1a59bf9c2076eda5884e89249af12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and store the actual hash value in a buffer.  <a href="#ga65e1a59bf9c2076eda5884e89249af12">More...</a><br /></td></tr>
<tr class="separator:ga65e1a59bf9c2076eda5884e89249af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga8316ebcbe11caebc88b4c4afc0eef16c">av_hash_final_hex</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>, <a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *dst, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="hash_8c.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="memdesc:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and store the hexadecimal representation of the actual hash value as a string.  <a href="#ga8316ebcbe11caebc88b4c4afc0eef16c">More...</a><br /></td></tr>
<tr class="separator:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga2300a29e15fd439bcac2f9bc35b730ca">av_hash_final_b64</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>, <a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *dst, <a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> <a class="el" href="hash_8c.html#a439227feff9d7f55384e8780cfc2eb82">size</a>)</td></tr>
<tr class="memdesc:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and store the Base64 representation of the actual hash value as a string.  <a href="#ga2300a29e15fd439bcac2f9bc35b730ca">More...</a><br /></td></tr>
<tr class="separator:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8bac529966e9af25f3608d3a1515ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a> (struct <a class="el" href="structAVHashContext.html">AVHashContext</a> **<a class="el" href="tests_2movenc_8c.html#a93cc7296f13f507c1fd7abd0db36b898">ctx</a>)</td></tr>
<tr class="memdesc:ga1e8bac529966e9af25f3608d3a1515ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free hash context and set hash context pointer to <code>NULL</code>.  <a href="#ga1e8bac529966e9af25f3608d3a1515ab">More...</a><br /></td></tr>
<tr class="separator:ga1e8bac529966e9af25f3608d3a1515ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>An abstraction layer for all hash functions supported by libavutil. </p>
<p>If your application needs to support a wide range of different hash functions, then the Generic Hashing API is for you. It provides a generic, reusable API for <a class="el" href="group__lavu__hash.html">all hash functions</a> implemented in libavutil. If you just need to use one particular hash function, use the <a class="el" href="group__lavu__hash.html">individual hash</a> directly.</p>
<h1><a class="anchor" id="Sample"></a>
Code</h1>
<p>A basic template for using the Generic Hashing API follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structAVHashContext.html">AVHashContext</a> *ctx = <a class="code" href="ff__glob_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *hash_name = <a class="code" href="ff__glob_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"><a class="code" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *output_buf = <a class="code" href="ff__glob_8c.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line"></div><div class="line"><span class="comment">// Select from a string returned by av_hash_names()</span></div><div class="line">hash_name = ...;</div><div class="line"></div><div class="line"><span class="comment">// Allocate a hash context</span></div><div class="line">ret = <a class="code" href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a>(&amp;ctx, hash_name);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0)</div><div class="line">    <span class="keywordflow">return</span> ret;</div><div class="line"></div><div class="line"><span class="comment">// Initialize the hash context</span></div><div class="line"><a class="code" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a>(ctx);</div><div class="line"></div><div class="line"><span class="comment">// Update the hash context with data</span></div><div class="line"><span class="keywordflow">while</span> (data_left) {</div><div class="line">    <a class="code" href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a>(ctx, <a class="code" href="mxf_8c.html#a084824fc871e38157790c99ae1240842">data</a>, <a class="code" href="twinvq__data_8h.html#a439227feff9d7f55384e8780cfc2eb82">size</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Now we have no more data, so it is time to finalize the hash and get the</span></div><div class="line"><span class="comment">// output. But we need to first allocate an output buffer. Note that you can</span></div><div class="line"><span class="comment">// use any memory allocation function, including malloc(), not just</span></div><div class="line"><span class="comment">// av_malloc().</span></div><div class="line">output_buf = <a class="code" href="tableprint__vlc_8h.html#ae97db1f58b6b1515ed57a83bea3dd572">av_malloc</a>(<a class="code" href="hash_8c.html#ad5b8ff78d2bd46a9a6cca5313e218c64">av_hash_get_size</a>(ctx));</div><div class="line"><span class="keywordflow">if</span> (!output_buf)</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR</a>(ENOMEM);</div><div class="line"></div><div class="line"><span class="comment">// Finalize the hash context.</span></div><div class="line"><span class="comment">// You can use any of the av_hash_final*() functions provided, for other</span></div><div class="line"><span class="comment">// output formats. If you do so, be sure to adjust the memory allocation</span></div><div class="line"><span class="comment">// above. See the function documentation below for the exact amount of extra</span></div><div class="line"><span class="comment">// memory needed.</span></div><div class="line"><a class="code" href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a>(ctx, output_buffer);</div><div class="line"></div><div class="line"><span class="comment">// Free the context</span></div><div class="line"><a class="code" href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a>(&amp;ctx);</div></div><!-- fragment --><h1><a class="anchor" id="Hash"></a>
Function-Specific Information</h1>
<p>If the CRC32 hash is selected, the <a class="el" href="group__lavu__crc32.html#ggab7717a9f1179a5ac8516982f9f2997d2a2c95e44f51d497669d7c49d58018dea1">AV_CRC_32_IEEE</a> polynomial will be used.</p>
<p>If the Murmur3 hash is selected, the default seed will be used. See <a class="el" href="group__lavu__murmur3.html#lavu_murmur3_seedinfo">Murmur3</a> for more information. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaff5173f8837eb3afbd20b52528833d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5173f8837eb3afbd20b52528833d72">&sect;&nbsp;</a></span>AV_HASH_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AV_HASH_MAX_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value that <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a> will currently return. </p>
<p>You can use this if you absolutely want or need to use static allocation for the output buffer and are fine with not supporting hashes newly added to libavutil without recompilation.</p>
<dl class="section warning"><dt>Warning</dt><dd>Adding new hashes with larger sizes, and increasing the macro while doing so, will not be considered an ABI change. To prevent your code from overflowing a buffer, either dynamically allocate the output buffer with <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>, or limit your use of the Hashing API to hashes that are already in FFmpeg during the time of compilation. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a7">ffhash.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="hash_8h_source.html#l00155">155</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

<p>Referenced by <a class="el" href="hash_8c_source.html#l00221">av_hash_final_b64()</a>, <a class="el" href="hash_8c_source.html#l00200">av_hash_final_bin()</a>, <a class="el" href="hash_8c_source.html#l00211">av_hash_final_hex()</a>, <a class="el" href="ffhash_8c_source.html#l00062">finish()</a>, and <a class="el" href="ffprobe_8c_source.html#l00745">writer_print_data_hash()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1e018687f3a0e9baf3fb6d3af0dd10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e018687f3a0e9baf3fb6d3af0dd10b">&sect;&nbsp;</a></span>av_hash_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hash_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> **&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a hash context for the algorithm specified by name. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 for success, a negative error code for failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The context is not initialized after a call to this function; you must call <a class="el" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca" title="Initialize or reset a hash context. ">av_hash_init()</a> to do so. </dd></dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00100">100</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffprobe_8c_source.html#l03261">main()</a>.</p>

</div>
</div>
<a id="ga62537bbcf4cae67bbb33f3fa4f4329bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62537bbcf4cae67bbb33f3fa4f4329bf">&sect;&nbsp;</a></span>av_hash_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_hash_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of available hash algorithms. </p>
<p>This function can be used to enumerate the algorithms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the hash algorithm, starting from 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a static string or <code>NULL</code> if <code>i</code> is out of range </dd></dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00084">84</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffprobe_8c_source.html#l03261">main()</a>, and <a class="el" href="ffhash_8c_source.html#l00046">usage()</a>.</p>

</div>
</div>
<a id="ga5952d21d5503ac307fbaa5d05a3d93ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5952d21d5503ac307fbaa5d05a3d93ca">&sect;&nbsp;</a></span>av_hash_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_hash_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the algorithm corresponding to the given hash context. </p>

</div>
</div>
<a id="ga8bf8f94e3ebf73f838d017f83352d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf8f94e3ebf73f838d017f83352d880">&sect;&nbsp;</a></span>av_hash_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a> av_hash_get_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the resulting hash value in bytes. </p>
<p>The maximum value this function will currently return is available as macro <a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72" title="Maximum value that av_hash_get_size() will currently return. ">AV_HASH_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the hash value in bytes </dd></dl>

</div>
</div>
<a id="ga84ef872a731eb5c2637ddcd0f0976bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ef872a731eb5c2637ddcd0f0976bca">&sect;&nbsp;</a></span>av_hash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize or reset a hash context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00137">137</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffhash_8c_source.html#l00076">check()</a>, <a class="el" href="tests_2hash_8c_source.html#l00029">main()</a>, and <a class="el" href="ffprobe_8c_source.html#l00745">writer_print_data_hash()</a>.</p>

</div>
</div>
<a id="gac6a467ff60cb5080b56e818e7b8adb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a467ff60cb5080b56e818e7b8adb4a">&sect;&nbsp;</a></span>av_hash_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a hash context with additional data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Data to be added to the hash context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the additional data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00158">158</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffhash_8c_source.html#l00076">check()</a>, <a class="el" href="tests_2hash_8c_source.html#l00029">main()</a>, and <a class="el" href="ffprobe_8c_source.html#l00745">writer_print_data_hash()</a>.</p>

</div>
</div>
<a id="gaeff9a69f576f8f94e33a0b43a08baa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff9a69f576f8f94e33a0b43a08baa70">&sect;&nbsp;</a></span>av_hash_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_final </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and compute the actual hash value. </p>
<p>The minimum size of <code>dst</code> buffer is given by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a> or <a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72" title="Maximum value that av_hash_get_size() will currently return. ">AV_HASH_MAX_SIZE</a>. The use of the latter macro is discouraged.</p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__hash__generic.html#ga65e1a59bf9c2076eda5884e89249af12" title="Finalize a hash context and store the actual hash value in a buffer. ">av_hash_final_bin()</a> provides an alternative API </dd></dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00179">179</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="hash_8c_source.html#l00221">av_hash_final_b64()</a>, <a class="el" href="hash_8c_source.html#l00200">av_hash_final_bin()</a>, and <a class="el" href="hash_8c_source.html#l00211">av_hash_final_hex()</a>.</p>

</div>
</div>
<a id="ga65e1a59bf9c2076eda5884e89249af12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e1a59bf9c2076eda5884e89249af12">&sect;&nbsp;</a></span>av_hash_final_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_final_bin </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and store the actual hash value in a buffer. </p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p>If <code>size</code> is smaller than the hash size (given by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>), the hash is truncated; if size is larger, the buffer is padded with 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00200">200</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="tests_2hash_8c_source.html#l00029">main()</a>.</p>

</div>
</div>
<a id="ga8316ebcbe11caebc88b4c4afc0eef16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8316ebcbe11caebc88b4c4afc0eef16c">&sect;&nbsp;</a></span>av_hash_final_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_final_hex </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and store the hexadecimal representation of the actual hash value as a string. </p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p>The string is always 0-terminated.</p>
<p>If <code>size</code> is smaller than <code>2 * hash_size + 1</code>, where <code>hash_size</code> is the value returned by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the string will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00211">211</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffhash_8c_source.html#l00062">finish()</a>, <a class="el" href="tests_2hash_8c_source.html#l00029">main()</a>, and <a class="el" href="ffprobe_8c_source.html#l00745">writer_print_data_hash()</a>.</p>

</div>
</div>
<a id="ga2300a29e15fd439bcac2f9bc35b730ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2300a29e15fd439bcac2f9bc35b730ca">&sect;&nbsp;</a></span>av_hash_final_b64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_final_b64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="audio__convert_8c.html#ae1affc9ca37cfb624959c866a73f83c2">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ffmpeg__filter_8c.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and store the Base64 representation of the actual hash value as a string. </p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p>The string is always 0-terminated.</p>
<p>If <code>size</code> is smaller than <a class="el" href="group__lavu__base64.html#gaa79f39ca3f737b662ae6711d2cbecd20" title="Calculate the output size needed to base64-encode x bytes to a null-terminated string. ">AV_BASE64_SIZE(hash_size)</a>, where <code>hash_size</code> is the value returned by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00221">221</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffhash_8c_source.html#l00062">finish()</a>, and <a class="el" href="tests_2hash_8c_source.html#l00029">main()</a>.</p>

</div>
</div>
<a id="ga1e8bac529966e9af25f3608d3a1515ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8bac529966e9af25f3608d3a1515ab">&sect;&nbsp;</a></span>av_hash_freep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rematrix__template_8c.html#a4dfdfbb7b69470f1152e022432ee2d45">void</a> av_hash_freep </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVHashContext.html">AVHashContext</a> **&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free hash context and set hash context pointer to <code>NULL</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Pointer to hash context </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash_8c_source.html#l00234">234</a> of file <a class="el" href="hash_8c_source.html">hash.c</a>.</p>

<p>Referenced by <a class="el" href="ffprobe_8c_source.html#l03261">main()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 2 2017 22:49:09 for FFmpeg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
